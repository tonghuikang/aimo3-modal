<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tokens Viewer</title>
    <script type="module">
        // Import js-tiktoken from CDN (esm.sh provides ES module builds)
        import { Tiktoken } from 'https://esm.sh/js-tiktoken@1.0.21';

        // Load o200k_base encoding ranks from local file
        const o200kRanks = await fetch('o200k_base.json').then(r => r.json());

        // Create encoder with harmony special tokens
        const specialTokens = {
            '<|endoftext|>': 199999,
            '<|startoftext|>': 199998,
            '<|return|>': 200002,
            '<|constrain|>': 200003,
            '<|channel|>': 200005,
            '<|start|>': 200006,
            '<|end|>': 200007,
            '<|message|>': 200008,
            '<|call|>': 200012
        };

        window.tiktoken = new Tiktoken(o200kRanks, specialTokens);
        window.tiktokenReady = true;

        // Load tokens after tiktoken is ready
        // Use setTimeout to ensure the inline script has defined loadDefaultTokens
        setTimeout(() => {
            if (typeof window.loadDefaultTokens === 'function') {
                window.loadDefaultTokens();
            }
        }, 0);
    </script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a2e;
            color: #eee;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: #16213e;
            padding: 15px 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            border-bottom: 1px solid #0f3460;
            flex-wrap: wrap;
        }

        .header h1 {
            font-size: 1.2rem;
            color: #e94560;
        }

        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        input[type="file"] {
            display: none;
        }

        button {
            background-color: #e94560;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }

        button:hover {
            background-color: #ff6b6b;
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        .btn-secondary {
            background-color: #0f3460;
        }

        .btn-secondary:hover {
            background-color: #1a4a7a;
        }

        .status {
            font-size: 0.85rem;
            color: #888;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #0f3460;
        }

        #tokens-panel {
            flex: 0 0 180px;
            min-width: 180px;
        }

        #text-panel {
            flex: 2;
        }

        #conversation-panel {
            flex: 2;
        }

        .panel:last-child {
            border-right: none;
        }

        .panel-header {
            background-color: #0f3460;
            padding: 10px 15px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-weight: bold;
            font-size: 0.9rem;
            color: #e94560;
            border-bottom: 1px solid #16213e;
            display: flex;
            justify-content: space-between;
            align-items: center;
            white-space: nowrap;
        }

        .panel-header span {
            font-size: 0.75rem;
            color: #888;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            white-space: pre-wrap;
            word-break: break-word;
            background-color: #16213e;
            line-height: 1.6;
        }

        #tokens-panel .panel-content {
            color: #888;
        }

        #text-panel .panel-content {
            color: #a8e6cf;
        }

        #conversation-panel .panel-content {
            color: #ffd93d;
        }

        .token-line {
            cursor: pointer;
            padding: 1px 4px;
            border-radius: 2px;
            transition: background-color 0.1s;
        }

        .token-line:hover {
            background-color: rgba(233, 69, 96, 0.2);
        }

        .token-line.highlighted {
            background-color: rgba(233, 69, 96, 0.5);
        }

        .text-token {
            cursor: pointer;
            border-radius: 2px;
            transition: background-color 0.1s;
        }

        .text-token:hover {
            background-color: rgba(168, 230, 207, 0.3);
        }

        .text-token.highlighted {
            background-color: rgba(233, 69, 96, 0.5);
        }

        .conv-segment {
            cursor: pointer;
            border-radius: 2px;
            transition: background-color 0.1s;
        }

        .conv-segment:hover {
            background-color: rgba(255, 217, 61, 0.3);
        }

        .conv-segment.highlighted {
            background-color: rgba(233, 69, 96, 0.5);
        }

        .message-block {
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 6px;
            background-color: rgba(255, 255, 255, 0.05);
        }

        .message-header {
            font-weight: bold;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .message-header.system { color: #ff6b6b; }
        .message-header.developer { color: #ffa500; }
        .message-header.user { color: #00d9ff; }
        .message-header.assistant { color: #10b981; }
        .message-header.python { color: #f0db4f; }
        .message-header.tool { color: #9b59b6; }

        .channel-tag {
            display: inline-block;
            font-size: 0.7rem;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            background-color: rgba(255, 255, 255, 0.1);
            color: #888;
        }

        .error {
            color: #ff6b6b;
            padding: 10px;
            background-color: rgba(255, 107, 107, 0.1);
            border-radius: 4px;
        }

        .file-label {
            background-color: #0f3460;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
            display: inline-block;
        }

        .file-label:hover {
            background-color: #1a4a7a;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Tokens Viewer</h1>
        <div class="status" id="status">Loading...</div>
    </div>

    <div class="main-container">
        <div class="panel" id="tokens-panel">
            <div class="panel-header">
                Tokens
                <span id="token-count">0 tokens</span>
            </div>
            <div class="panel-content" id="tokens-content"></div>
        </div>
        <div class="panel" id="text-panel">
            <div class="panel-header">
                Text
                <span id="text-info"></span>
            </div>
            <div class="panel-content" id="text-content"></div>
        </div>
        <div class="panel" id="conversation-panel">
            <div class="panel-header">
                Conversation
                <span id="conv-info"></span>
            </div>
            <div class="panel-content" id="conversation-content"></div>
        </div>
    </div>

    <script>
        let tokenIds = [];
        let tokenGroups = [];
        let conversationSegments = [];

        // Special token patterns for harmony encoding (from tiktoken o200k_harmony)
        const SPECIAL_TOKENS = {
            199998: '<|startoftext|>',
            199999: '<|endoftext|>',
            200002: '<|return|>',
            200003: '<|constrain|>',
            200005: '<|channel|>',
            200006: '<|start|>',
            200007: '<|end|>',
            200008: '<|message|>',
            200012: '<|call|>'
        };

        // Reverse mapping from special token name to ID
        const SPECIAL_TOKEN_IDS = Object.fromEntries(
            Object.entries(SPECIAL_TOKENS).map(([id, name]) => [name, parseInt(id)])
        );

        const ROLES = ['system', 'developer', 'user', 'assistant'];
        const CHANNELS = ['analysis', 'commentary', 'final'];


        function displayTokens() {
            const container = document.getElementById('tokens-content');
            container.innerHTML = '';

            tokenIds.forEach((tokenId, index) => {
                const div = document.createElement('div');
                div.className = 'token-line';
                div.textContent = tokenId;
                div.dataset.index = index;
                div.onclick = () => highlightByTokenIndex(index);
                container.appendChild(div);
            });

            document.getElementById('token-count').textContent = `${tokenIds.length} tokens`;
        }

        async function decodeTokens() {
            if (tokenIds.length === 0) {
                document.getElementById('status').textContent = 'No tokens to decode';
                return;
            }

            const status = document.getElementById('status');
            status.textContent = 'Decoding tokens...';

            // Wait for tiktoken to be ready
            if (!window.tiktokenReady) {
                status.textContent = 'Waiting for tokenizer to load...';
                await new Promise(resolve => {
                    window.addEventListener('tiktokenReady', resolve, { once: true });
                });
            }

            try {
                // Decode tokens using js-tiktoken
                tokenGroups = [];

                for (let i = 0; i < tokenIds.length; i++) {
                    const tokenId = tokenIds[i];
                    let text;

                    // Check if it's a special token
                    if (SPECIAL_TOKENS[tokenId]) {
                        text = SPECIAL_TOKENS[tokenId];
                    } else {
                        // Decode using tiktoken
                        try {
                            const decoded = window.tiktoken.decode([tokenId]);
                            text = decoded;
                        } catch (e) {
                            text = `[${tokenId}]`;
                        }
                    }

                    tokenGroups.push({
                        text: text,
                        indices: [i]
                    });
                }

                displayText();
                parseConversation();
                displayConversation();

                status.textContent = `Decoded ${tokenIds.length} tokens into ${tokenGroups.length} groups`;
            } catch (error) {
                status.textContent = `Decode error: ${error.message}`;
                document.getElementById('text-content').innerHTML =
                    `<div class="error">Error: ${error.message}</div>`;
            }
        }

        function displayText() {
            const container = document.getElementById('text-content');
            container.innerHTML = '';

            tokenGroups.forEach((group, groupIndex) => {
                const span = document.createElement('span');
                span.className = 'text-token';
                span.textContent = group.text;
                span.dataset.indices = JSON.stringify(group.indices);
                span.dataset.groupIndex = groupIndex;
                span.onclick = () => highlightByGroup(group.indices, groupIndex, 'text');
                container.appendChild(span);
            });
        }

        function parseConversation() {
            // Parse the harmony encoding into conversation segments
            // Harmony format: <|start|>{role}<|message|>{content}<|end|>
            // Or with channel: <|start|>{role}<|channel|>{channel}<|message|>{content}<|end|>
            // Tool calls: <|call|><|start|>{tool} to={recipient}<|channel|>{channel}<|message|>{content}<|end|>
            conversationSegments = [];

            let currentRole = null;
            let currentChannel = null;
            let currentRecipient = null;
            let currentContent = [];
            let currentStartIndex = 0;
            let inMessage = false;
            let isToolCall = false;
            let parsingHeader = false;  // Are we parsing the header (role/to=/channel) before <|message|>?

            const TOOL_NAMES = ['python', 'tool'];

            for (let i = 0; i < tokenGroups.length; i++) {
                const group = tokenGroups[i];
                const text = group.text;
                const firstTokenId = tokenIds[group.indices[0]];

                // Check for <|call|> - marks start of tool interaction
                if (firstTokenId === 200012) {
                    isToolCall = true;
                    continue;
                }

                // Check for special tokens
                if (firstTokenId === 200006) {
                    // <|start|> - start of a new message
                    if (currentRole && currentContent.length > 0) {
                        conversationSegments.push({
                            role: currentRole,
                            channel: currentChannel,
                            recipient: currentRecipient,
                            content: currentContent.slice(),
                            groupIndices: { start: currentStartIndex, end: i - 1 }
                        });
                    }
                    currentRole = null;
                    currentContent = [];
                    currentChannel = null;
                    currentRecipient = null;
                    currentStartIndex = i;
                    inMessage = true;
                    parsingHeader = true;
                    continue;
                }

                if (firstTokenId === 200007) {
                    // <|end|> - end of message
                    if (currentRole && currentContent.length > 0) {
                        conversationSegments.push({
                            role: currentRole,
                            channel: currentChannel,
                            recipient: currentRecipient,
                            content: currentContent.slice(),
                            groupIndices: { start: currentStartIndex, end: i }
                        });
                    }
                    currentRole = null;
                    currentChannel = null;
                    currentRecipient = null;
                    currentContent = [];
                    inMessage = false;
                    isToolCall = false;
                    parsingHeader = false;
                    continue;
                }

                if (firstTokenId === 200008) {
                    // <|message|> - message content follows, header parsing done
                    parsingHeader = false;
                    continue;
                }

                if (firstTokenId === 200005) {
                    // <|channel|> - channel follows (still in header)
                    continue;
                }

                // If we're parsing the header (before <|message|>)
                if (parsingHeader) {
                    const trimmedText = text.trim().toLowerCase();

                    // Check if this is a role/tool token
                    if (!currentRole) {
                        if (ROLES.includes(trimmedText)) {
                            currentRole = trimmedText;
                            continue;
                        }
                        if (TOOL_NAMES.includes(trimmedText)) {
                            currentRole = trimmedText;
                            continue;
                        }
                    }

                    // Check for "to" keyword
                    if (trimmedText === 'to') {
                        continue;  // Skip, next token should be "="
                    }

                    // Check for "=" after "to"
                    if (trimmedText === '=') {
                        continue;  // Skip, next token should be recipient
                    }

                    // Check if this is a recipient (after to=) - can be a role or tool name
                    if ((ROLES.includes(trimmedText) || TOOL_NAMES.includes(trimmedText)) && !currentRecipient) {
                        currentRecipient = trimmedText;
                        continue;
                    }

                    // Check if this is a channel token
                    if (CHANNELS.includes(trimmedText)) {
                        currentChannel = trimmedText;
                        continue;
                    }

                    // Unknown header token, skip
                    continue;
                }

                // Regular content (after <|message|>)
                if (inMessage && !parsingHeader) {
                    currentContent.push({ group, groupIndex: i });
                }
            }

            // Handle any remaining content
            if (currentRole && currentContent.length > 0) {
                conversationSegments.push({
                    role: currentRole,
                    channel: currentChannel,
                    recipient: currentRecipient,
                    content: currentContent.slice(),
                    groupIndices: { start: currentStartIndex, end: tokenGroups.length - 1 }
                });
            }
        }

        function displayConversation() {
            const container = document.getElementById('conversation-content');
            container.innerHTML = '';

            conversationSegments.forEach((segment, segIndex) => {
                const block = document.createElement('div');
                block.className = 'message-block';

                const header = document.createElement('div');
                header.className = `message-header ${segment.role}`;

                // Build header with channel tag positioned based on direction:
                // Tool → Role: "python → assistant [analysis]" (channel at end)
                // Role to Tool: "assistant [analysis] to python" (channel before "to")
                const roleName = segment.role;
                const recipientName = segment.recipient || null;
                const isToolRole = segment.role === 'python' || segment.role === 'tool';
                const isToolRecipient = segment.recipient === 'python' || segment.recipient === 'tool';

                // The role token is typically at start+1 (after <|start|>)
                const roleGroupIndex = segment.groupIndices.start + 1;
                const roleGroup = tokenGroups[roleGroupIndex];

                // Find "to", channel, and recipient group indices in the header tokens
                let toGroupIndex = null;
                let channelGroupIndex = null;
                let recipientGroupIndex = null;
                // Search for all header tokens (between start and message)
                for (let i = roleGroupIndex + 1; i < segment.groupIndices.end; i++) {
                    const group = tokenGroups[i];
                    const trimmedText = group.text.trim().toLowerCase();
                    if (trimmedText === 'to' && toGroupIndex === null) {
                        toGroupIndex = i;
                    }
                    if (segment.channel && trimmedText === segment.channel && channelGroupIndex === null) {
                        channelGroupIndex = i;
                    }
                    if (recipientName && trimmedText === recipientName) {
                        recipientGroupIndex = i;
                    }
                    // Stop if we hit <|message|>
                    if (tokenIds[group.indices[0]] === 200008) break;
                }

                // Create clickable role span
                const roleSpan = document.createElement('span');
                roleSpan.textContent = roleName;
                roleSpan.style.cursor = 'pointer';
                roleSpan.className = 'conv-header';
                if (roleGroup) {
                    roleSpan.dataset.groupIndex = roleGroupIndex;
                    roleSpan.onclick = (e) => {
                        e.stopPropagation();
                        highlightByGroup(roleGroup.indices, roleGroupIndex, 'conversation');
                    };
                }

                // Helper function to create clickable "to" span
                function createToSpan() {
                    const toSpan = document.createElement('span');
                    toSpan.textContent = ' to ';
                    toSpan.style.cursor = 'pointer';
                    toSpan.className = 'conv-header';
                    if (toGroupIndex !== null) {
                        const toGroup = tokenGroups[toGroupIndex];
                        toSpan.dataset.groupIndex = toGroupIndex;
                        toSpan.onclick = (e) => {
                            e.stopPropagation();
                            highlightByGroup(toGroup.indices, toGroupIndex, 'conversation');
                        };
                    }
                    return toSpan;
                }

                // Helper function to create clickable channel span
                function createChannelSpan() {
                    const channelTag = document.createElement('span');
                    channelTag.className = 'channel-tag';
                    channelTag.textContent = segment.channel;
                    channelTag.style.cursor = 'pointer';
                    if (channelGroupIndex !== null) {
                        const channelGroup = tokenGroups[channelGroupIndex];
                        channelTag.dataset.groupIndex = channelGroupIndex;
                        channelTag.classList.add('conv-header');
                        channelTag.onclick = (e) => {
                            e.stopPropagation();
                            highlightByGroup(channelGroup.indices, channelGroupIndex, 'conversation');
                        };
                    }
                    return channelTag;
                }

                if (isToolRole && recipientName) {
                    // Tool output to role: "python to assistant [analysis]"
                    header.appendChild(roleSpan);
                    header.appendChild(createToSpan());

                    // Clickable recipient
                    const recipientSpan = document.createElement('span');
                    recipientSpan.textContent = recipientName;
                    recipientSpan.style.cursor = 'pointer';
                    recipientSpan.className = 'conv-header';
                    if (recipientGroupIndex !== null) {
                        const recipientGroup = tokenGroups[recipientGroupIndex];
                        recipientSpan.dataset.groupIndex = recipientGroupIndex;
                        recipientSpan.onclick = (e) => {
                            e.stopPropagation();
                            highlightByGroup(recipientGroup.indices, recipientGroupIndex, 'conversation');
                        };
                    }
                    header.appendChild(recipientSpan);

                    if (segment.channel) {
                        header.appendChild(createChannelSpan());
                    }
                } else if (isToolRecipient) {
                    // Role to tool: "assistant [analysis] to python"
                    header.appendChild(roleSpan);
                    if (segment.channel) {
                        header.appendChild(createChannelSpan());
                    }
                    header.appendChild(createToSpan());

                    // Clickable recipient
                    const recipientSpan = document.createElement('span');
                    recipientSpan.textContent = recipientName;
                    recipientSpan.style.cursor = 'pointer';
                    recipientSpan.className = 'conv-header';
                    if (recipientGroupIndex !== null) {
                        const recipientGroup = tokenGroups[recipientGroupIndex];
                        recipientSpan.dataset.groupIndex = recipientGroupIndex;
                        recipientSpan.onclick = (e) => {
                            e.stopPropagation();
                            highlightByGroup(recipientGroup.indices, recipientGroupIndex, 'conversation');
                        };
                    }
                    header.appendChild(recipientSpan);
                } else {
                    // Normal message: "role [channel]"
                    header.appendChild(roleSpan);
                    if (segment.channel) {
                        header.appendChild(createChannelSpan());
                    }
                }

                block.appendChild(header);

                const content = document.createElement('div');
                content.className = 'message-content';

                segment.content.forEach(({ group, groupIndex }) => {
                    const span = document.createElement('span');
                    span.className = 'conv-segment';
                    span.textContent = group.text;
                    span.dataset.indices = JSON.stringify(group.indices);
                    span.dataset.groupIndex = groupIndex;
                    span.onclick = () => highlightByGroup(group.indices, groupIndex, 'conversation');
                    content.appendChild(span);
                });

                block.appendChild(content);
                container.appendChild(block);
            });

            document.getElementById('conv-info').textContent = `${conversationSegments.length} messages`;
        }

        function highlightByTokenIndex(index) {
            // Find which group contains this token index
            let targetGroup = null;
            let targetGroupIndex = -1;

            for (let i = 0; i < tokenGroups.length; i++) {
                if (tokenGroups[i].indices.includes(index)) {
                    targetGroup = tokenGroups[i];
                    targetGroupIndex = i;
                    break;
                }
            }

            if (targetGroup) {
                highlightByGroup(targetGroup.indices, targetGroupIndex, 'tokens');
            }
        }

        function highlightByGroup(indices, groupIndex, sourcePanel) {
            // Clear all highlights
            document.querySelectorAll('.token-line.highlighted').forEach(el => el.classList.remove('highlighted'));
            document.querySelectorAll('.text-token.highlighted').forEach(el => el.classList.remove('highlighted'));
            document.querySelectorAll('.conv-segment.highlighted').forEach(el => el.classList.remove('highlighted'));
            document.querySelectorAll('.conv-header.highlighted').forEach(el => el.classList.remove('highlighted'));

            // Highlight tokens
            indices.forEach(idx => {
                const tokenEl = document.querySelector(`.token-line[data-index="${idx}"]`);
                if (tokenEl) {
                    tokenEl.classList.add('highlighted');
                }
            });

            // Highlight text
            const textEl = document.querySelector(`.text-token[data-group-index="${groupIndex}"]`);
            if (textEl) {
                textEl.classList.add('highlighted');
            }

            // Highlight conversation content or header
            const convEl = document.querySelector(`.conv-segment[data-group-index="${groupIndex}"]`);
            if (convEl) {
                convEl.classList.add('highlighted');
            }
            // Also check for header with this group index (for role names)
            const headerEl = document.querySelector(`.conv-header[data-group-index="${groupIndex}"]`);
            if (headerEl) {
                headerEl.classList.add('highlighted');
            }

            // Scroll other panels to align (not the source panel)
            scrollToHighlighted(sourcePanel);
        }

        function scrollElementToTargetY(panel, element, targetY) {
            if (!panel || !element) return;

            // Calculate where the element currently is
            const panelRect = panel.getBoundingClientRect();
            const elementRect = element.getBoundingClientRect();

            // Calculate how much to scroll to put element at targetY position within panel
            const currentY = elementRect.top - panelRect.top;
            const scrollDelta = currentY - targetY;

            panel.scrollTop = Math.max(0, panel.scrollTop + scrollDelta);
        }

        function scrollToHighlighted(sourcePanel) {
            // Get the source panel's highlighted element position to align others to it
            let targetY = null;

            if (sourcePanel === 'tokens') {
                const tokensPanel = document.getElementById('tokens-content');
                const highlightedToken = document.querySelector('.token-line.highlighted');
                if (tokensPanel && highlightedToken) {
                    const panelRect = tokensPanel.getBoundingClientRect();
                    const elemRect = highlightedToken.getBoundingClientRect();
                    targetY = elemRect.top - panelRect.top;
                }
            } else if (sourcePanel === 'text') {
                const textPanel = document.getElementById('text-content');
                const highlightedText = document.querySelector('.text-token.highlighted');
                if (textPanel && highlightedText) {
                    const panelRect = textPanel.getBoundingClientRect();
                    const elemRect = highlightedText.getBoundingClientRect();
                    targetY = elemRect.top - panelRect.top;
                }
            } else if (sourcePanel === 'conversation') {
                const convPanel = document.getElementById('conversation-content');
                const highlightedConv = document.querySelector('.conv-segment.highlighted') || document.querySelector('.conv-header.highlighted');
                if (convPanel && highlightedConv) {
                    const panelRect = convPanel.getBoundingClientRect();
                    const elemRect = highlightedConv.getBoundingClientRect();
                    targetY = elemRect.top - panelRect.top;
                }
            }

            // Default to centering if we can't get source position
            if (targetY === null) {
                targetY = 300; // roughly center
            }

            // Scroll tokens panel (unless it's the source)
            if (sourcePanel !== 'tokens') {
                const tokensPanel = document.getElementById('tokens-content');
                const highlightedToken = document.querySelector('.token-line.highlighted');
                scrollElementToTargetY(tokensPanel, highlightedToken, targetY);
            }

            // Scroll text panel (unless it's the source)
            if (sourcePanel !== 'text') {
                const textPanel = document.getElementById('text-content');
                const highlightedText = document.querySelector('.text-token.highlighted');
                scrollElementToTargetY(textPanel, highlightedText, targetY);
            }

            // Scroll conversation panel (unless it's the source)
            if (sourcePanel !== 'conversation') {
                const convPanel = document.getElementById('conversation-content');
                const highlightedConv = document.querySelector('.conv-segment.highlighted') || document.querySelector('.conv-header.highlighted');
                scrollElementToTargetY(convPanel, highlightedConv, targetY);
            }
        }

        // Load default token file on page load
        window.loadDefaultTokens = async function loadDefaultTokens() {
            const status = document.getElementById('status');
            status.textContent = 'Loading tokenizer...';

            // Wait for tiktoken to be ready (check both flag and wait for event)
            if (!window.tiktokenReady) {
                await new Promise(resolve => {
                    // Check again in case it became ready while we were setting up
                    if (window.tiktokenReady) {
                        resolve();
                        return;
                    }
                    window.addEventListener('tiktokenReady', resolve, { once: true });
                });
            }

            status.textContent = 'Loading tokens...';

            try {
                const response = await fetch('tokens_demo.txt');
                if (!response.ok) {
                    status.textContent = 'Failed to load tokens file';
                    return;
                }
                const text = await response.text();
                tokenIds = text.trim().split('\n')
                    .map(line => parseInt(line.trim()))
                    .filter(n => !isNaN(n));

                displayTokens();
                status.textContent = `Loaded ${tokenIds.length} tokens, decoding...`;

                // Auto-decode after loading
                await decodeTokens();
            } catch (error) {
                status.textContent = `Error: ${error.message}`;
            }
        }

        // Module script will call window.loadDefaultTokens when ready
    </script>
</body>
</html>
